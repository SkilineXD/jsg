<!DOCTYPE html>

<html>
<head>
	<title>JSGWEBGL - A GRAPHICAL LIBRARY FOR JAVASCRIPT DEVELOPERS</title>
	<script type="text/javascript" src="gl-matrix.js"></script>
	<script type="text/javascript" src="sphere.js"></script>
	<script type="text/javascript" src="cubomagico.js"></script>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="jsg_collections.js"></script>
	<script type="text/javascript" src="jsgwebgl_obj.js"></script>
	<script type="text/javascript" src="jsgwebgl_shader.js"></script>
	<script type="text/javascript" src="jsgwebgl_light.js"></script>
	<script type="text/javascript" src="jsgwebgl_material.js"></script>
	<script type="text/javascript" src="jsgwebgl_cam.js"></script>
	<script type="text/javascript" src="jsgwebgl_scene.js"></script>
	<script type="text/javascript" src="jsgwebgl.js"></script>
	<script type="text/javascript" src="jsgutils.js"></script>
    <script type="x-shader/x-vertex" id="shadervs">
        const int MAX_POS_LIGHTS = 3;
        attribute vec3 aVertexPos;
        attribute vec3 aVertexNormal;
        attribute vec2 aVertexTextureCoords;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        uniform mat4 uNMatrix;
        uniform int uPosLights;
        uniform int uDirLights;
        uniform int uUseTexture;
        uniform vec4 uAmbientLight;
        uniform float uShininess;
        uniform vec4 uSpecularColor;
        uniform vec4 uMaterialColor;
        uniform vec4 uAmbientColor;
        uniform bool uUpdateLightPosition;
        uniform mat4 uLMatrix;
        uniform float uCutOff;
        uniform vec3 uLightPosition[MAX_POS_LIGHTS];
        uniform vec4 uLightSpecular[MAX_POS_LIGHTS];
        uniform	vec4 uPLightColor[MAX_POS_LIGHTS];
        uniform vec3 uLightPositionDir[MAX_POS_LIGHTS];
        uniform int shaderType;         
        
        varying vec3 eyeVec;
        varying vec3 vNormal;
        varying vec3 lightdir[MAX_POS_LIGHTS];
        varying vec4 vColor;
        varying vec2 vTextureCoords;
        
        void phong(void){
            vec4 vertex = uMVMatrix * vec4(aVertexPos, 1.0);
            eyeVec = -vertex.xyz;
            vNormal = vec3(uNMatrix * vec4(aVertexNormal, 1.0));
            for(int i = 0; i < MAX_POS_LIGHTS; i++){
                vec4 pos = uLMatrix * vec4(uLightPosition[i], 1.0);
                lightdir[i] = vertex.xyz - pos.xyz;
            }
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPos, 1.0);
            vTextureCoords = aVertexTextureCoords;
        }
        
        void goroud(void){
            vec4 vertex = uMVMatrix * vec4(aVertexPos, 1.0);
            vec3 eyeVec = -vec3(vertex.xyz);
            vec3 E = normalize(eyeVec);
            vec4 Ia = uAmbientLight * uAmbientColor;
            vColor = vec4(0.0, 0.0, 0.0, 1.0);
            
            for(int i = 0; i < MAX_POS_LIGHTS; i++){
                vec3 N = normalize(vec3(uNMatrix * vec4(aVertexNormal, 1.0))-uLightPositionDir[i]);
                vec4 pos = uLMatrix * vec4(uLightPosition[i], 1.0);
                vec3 lightdir = vertex.xyz - pos.xyz;
                vec3 L = normalize(lightdir);
                vec3 R = reflect(L, N);
                float lt = dot(N, -L);
                float specular = pow(max(dot(R,E), 0.0), uShininess);
                float f = 40.0001; 
                vec4 Id = uMaterialColor * uPLightColor[i] * pow(lt, f * uCutOff);
                vec4 Is = uSpecularColor * uLightSpecular[i] * specular;
                vColor += Id + Is;
            }
            vColor += Ia;
            vColor[3] = uMaterialColor[3];
            gl_Position = uPMatrix * vertex;
            gl_PointSize = 1.0;
            vTextureCoords = aVertexTextureCoords;
        }
        
        void main(void) {
            if (shaderType == 1){
                goroud();
            } else {
                phong();
            }
        }
    </script>
    <script type="x-shader/x-fragment" id="shaderfs">
        #ifdef GL_ES
        precision highp float;
        precision highp int;
        #endif

        const int MAX_POS_LIGHTS = 3;
        
        uniform int uUseTextureKa;
        uniform int uUseTextureKd;
        uniform sampler2D uSamplerKa;
        uniform sampler2D uSamplerKd;
        uniform vec4 uMaterialColor;
        uniform vec4 uAmbientColor;
        uniform int uPosLights;
        uniform int uDirLights;
        uniform float uShininess;
        uniform vec4 uSpecularColor;
        uniform vec4 uAmbientLight;
        uniform float uCutOff;
        uniform vec3 uLightPosition[MAX_POS_LIGHTS];
        uniform	vec4 uPLightColor[MAX_POS_LIGHTS];
        uniform vec4 uLightSpecular[MAX_POS_LIGHTS];
        uniform vec3 uLightPositionDir[MAX_POS_LIGHTS];
        uniform int shaderType;
        varying vec3 eyeVec;
        varying vec3 vNormal;
        varying vec3 lightdir[MAX_POS_LIGHTS];
        varying vec4 vColor;
        varying vec2 vTextureCoords;
        
        void phong(void){
            vec4 ambientMaterial = uAmbientColor;
            vec4 diffuseMaterial = uMaterialColor;
            if (uUseTextureKa == 1) {
                ambientMaterial = ambientMaterial * texture2D(uSamplerKa, vTextureCoords);
            }    
            if (uUseTextureKd == 1) {
                diffuseMaterial = diffuseMaterial  * texture2D(uSamplerKd, vTextureCoords);
            }
            vec3 E = normalize(eyeVec);
            vec4 Ia = uAmbientLight * ambientMaterial;
            vec4 fColor = vec4(0.0, 0.0, 0.0, 1.0);
            for(int i = 0; i < MAX_POS_LIGHTS; i++){
                vec3 N = normalize(vNormal-uLightPositionDir[i]);
                vec3 L = normalize(lightdir[i]);
                vec3 R = reflect(L, N);
                float lt = dot(N, -L);
                float specular = pow(max(dot(R,E), 0.0), uShininess);
                float f = 40.0001; 
                vec4 Id = diffuseMaterial * uPLightColor[i] * pow(lt, f * uCutOff);
                vec4 Is = uSpecularColor * uLightSpecular[i] * specular;
                fColor +=  Id + Is;
            }
            fColor += Ia;
            fColor[3] = uMaterialColor[3];
            gl_FragColor = fColor;
        }
        
        void goroud(void){
            vec4 color = vColor;
            if (uUseTextureKa == 1) {
                color = color * texture2D(uSamplerKa, vTextureCoords);
            } else if (uUseTextureKd == 1) {
                color = color  * texture2D(uSamplerKd, vTextureCoords); 
            }
            gl_FragColor = color;
        }
        
        void main(void) {
            if (shaderType == 1) {
                goroud();
            } else {
                phong();
            }
        }
    </script>
	<script type="text/javascript">
		var jsg, scene, shader, shaders, shininess=100, SPHERE_QTD = 300; objpos = [0, 0, 0], objdir = -1, pos = null, z = 0, az = 0, el = 0, roll = 0, cam;

		function init() {
			shaders = {};
			jsg = new jsggl.JsgGl("scenecanvas");
			jsg.display = display;
			jsg.initialize = initialize;
			jsg.finalize = finalize; 
		
			shaders["goraud"] = jsggl.GoraudShader;
			shaders["phong"] = jsggl.PhongShader;
			shader  = jsggl.GoraudShader;
			jsg.shader = new shader(jsg);
			scene = new jsggl.Scene("Default", jsg);

	
			jsggl.Material.loadFromJSON(jsg, cubomagicomtl);
			var cube = new jsggl.Object.loadFromJSON(cubomagico, "object");
			cube.showOneTime = false;
			scene.addObject(cube);		
		
			var floor = jsggl.builtin.getFloor(jsg, 50, 50);
			scene.addObject(floor);
            
			var proj = jsggl.Projection.newPerspective(30 * Math.PI/180.0, jsg.canvas.width/jsg.canvas.height, 0.1, 1000);
            var orth = jsggl.Projection.newOrtographic(-30, 30, -30, 30, 0.01, 30);

			scene.cameras["orbiting"] = new jsggl.Camera("orbiting", jsggl.Camera.ORBITING, orth);
			scene.cameras["tracking"] = new jsggl.Camera("tracking", jsggl.Camera.TRACKING, proj);
			scene.setActiveCamera("orbiting");
			
			cam = scene.getActiveCamera();
			
			installLights();			

			jsg.addScene(scene);
			
			jsg.setActiveScene(scene.name);	
			configureEvents();
			if (!jsg.build()){
				alert("Error: " + jsg.compileProgramStatus);			
			}			
			jsg.mainLoop();
		}
		
		function configureEvents() {
			$("#scenecanvas").mousedown(function(evt){
				pos = [evt.clientX, evt.clientY];
			});

			$("#scenecanvas").mouseleave(function(evt){
				pos = null;
			});

			$(document).keydown(function(evt){
				if (cam){ 
					switch(evt.which){
					case 38:
						z = -1;
						break;
					case 40:
						z = 1;
						break;
					}	

					cam.position[2] += z;
					cam.update();
				}
			});

			$("#scenecanvas").mouseup(function(evt){
				pos = null;
			});

			$("#scenecanvas").mousemove(function(evt){
				if (pos != null && cam) {
					var npos = [evt.clientX, evt.clientY, 0.0];
					var delta = [npos[0] - pos[0], npos[1] - pos[1]];
					delta[0] = delta[0] * 0.01;
					delta[1] = delta[1] * 0.01;
					cam.azimute += delta[0] * 10;
					cam.elevation += delta[1] * 10;
					cam.update();					
					pos = npos;
				}
			});
		}

		function initialize() {
			jsg.clearColor(0.3, 0.3, 0.3, 1.0);
			jsg.clearDepth(100.0);
			jsg.enableDepthTest();
			jsg.gl.enable(jsg.gl.BLEND);
			jsg.gl.blendEquation(jsg.gl.FUNC_ADD);
			jsg.gl.blendFunc(jsg.gl.SRC_ALPHA, jsg.gl.ONE_MINUS_SRC_ALPHA);
			jsg.depthFunc(jsg.gl.LEQUAL);
			jsg.viewport(0, 0, jsg.canvas.width, jsg.canvas.height);
		}
		
		function updateLights(){
			var x = parseFloat($("#txtX").attr("value")),
				y = parseFloat($("#txtY").attr("value")),
				z = parseFloat($("#txtZ").attr("value"));
			var R = parseFloat($("#txtR").attr("value")),
				G = parseFloat($("#txtG").attr("value")),
				B = parseFloat($("#txtB").attr("value"));
			var pos = [x, y, z];
			var color = [R, G, B, 1.0];
			var l = scene.lights.get("Red");
			l.position = pos;
			l.color = color;
			scene.updateLights();
			jsg.shader.setGlobalValues();
		}
		
		function installLights(){
			scene.lights.clear();
			var red = new jsggl.Light("Red", jsggl.Light.types.POSITIONAL).build([0.0, 2.0, -41.0], [1.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0], [0.0, 1.0, 0.0]);
			scene.addLight(red);
			var green = new jsggl.Light("Green", jsggl.Light.types.POSITIONAL).build([-1.0, 0.0, -41.0], [0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0], [-1.0, -1.0, 0.0]);
			scene.addLight(green);
			var blue = new jsggl.Light("Blue", jsggl.Light.types.POSITIONAL).build([1.0, 0.0, -41.0], [0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 0.0, 1.0], [1.0, -1.0, 0.0]);
			scene.addLight(blue);
			scene.updateLights();
			jsg.beforeDraw = function() {
				//jsg.lightMatrix = jsg.modelView;
			}
		}

		function display() {
			jsg.clear(jsg.COLOR_BUFFER_BIT | jsg.DEPTH_BUFFER_BIT);
			jsg.run();
		}
		
		function finalize() {
		
		}

		function setShininess(evt){
			shininess = evt.value;
		}	

		function selectShadingMethod(evt){
			shader = shaders[evt.value];
			jsg.shader = new shader(jsg);
			if (!jsg.build()){
				alert("Error: " + jsg.compileProgramStatus);			
			}	
		}

		function selectCameraType(evt){
			if (cam) {
				scene.setActiveCamera(evt.value);
				cam = scene.getActiveCamera();	
				cam.reset();
			}
		}

	</script>
</head>
<body onload="init();">
	<div>
		Utilize as setas para mudar a posi��o da c�mera. Para girar a cena, com o bot�o esquerdo pressionado, movimente o mouse.
	</div>
	<canvas id="scenecanvas" width="680" height="400" style="border: 1px dotted"></canvas>
	<div style="background: rgb(255, 255, 200);">	
		<div>Shading Method</div>
		<input type="radio" checked="true"  onchange="selectShadingMethod(this);" value="goraud" name="ShadingModel">Goraud</input>
		<input type="radio" onchange="selectShadingMethod(this);" value="phong" name="ShadingModel">Phong</input>
		<div>				
	</div>
	</div>
	<div>Camera Type</div>
	<div>
		<input type="radio" checked="true" onchange="selectCameraType(this);" value="orbiting" name="CameraType">Orbit</input>
		<input type="radio"   onchange="selectCameraType(this);" value="tracking" name="CameraType">Tracking</input>
	</div>
</body>
</html>

